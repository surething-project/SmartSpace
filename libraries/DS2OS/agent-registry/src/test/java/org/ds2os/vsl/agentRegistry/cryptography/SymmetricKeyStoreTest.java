package org.ds2os.vsl.agentRegistry.cryptography;

import static org.ds2os.vsl.netutils.TestHelper.randomData;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;

import java.security.InvalidParameterException;
import java.security.Security;
import java.util.Arrays;
import java.util.List;

import javax.xml.bind.DatatypeConverter;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.ds2os.vsl.agentregistry.cryptography.SymmetricKeyStore;
import org.ds2os.vsl.core.VslAgentRegistryService;
import org.ds2os.vsl.exception.KeyNotInKeystoreException;
import org.ds2os.vsl.netutils.KeyStringParser;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.Mockito;

/**
 * Test class the the SymmetricKeyStore.
 *
 * @author Johannes Stra√üer
 *
 */
public class SymmetricKeyStoreTest {

    /**
     * A randomly generated key that can be used by tests.
     */
    private byte[] key;

    /**
     * The VslSymmetricKeyStore for tests to use.
     */
    private SymmetricKeyStore keyStore;

    /**
     * Dummy TLS String for tests to use.
     */
    private static final String TLS_STRING = "TLS_PSK_WITH_AES_256_CBC_SHA384";

    /**
     * Add Bouncy Castle security provider in case JVM does not have all ciphers.
     */
    @BeforeClass
    public static final void loadBcprov() {
        Security.addProvider(new BouncyCastleProvider());
    }

    /**
     * Set up method to initialize global fields.
     */
    @Before
    public final void setUp() {
        this.keyStore = new SymmetricKeyStore();
        this.key = new KeyStringParser(TLS_STRING).createKey();
    }

    /**
     * Test if the addKey method works properly.
     */
    @Test
    public final void testAddKey() {
        // test valid key
        assertThat(this.keyStore.addKey(key, TLS_STRING), is(true));
        // test null key
        assertThat(this.keyStore.addKey(null, null), is(false));
        // test known cipher with wrong key size
        assertThat(this.keyStore.addKey(key, "TLS_PSK_WITH_AES_128_CBC_SHA"), is(false));
        // test known cipher with unsupported mAC size
        assertThat(this.keyStore.addKey(key, "TLS_PSK_WITH_AES_256_CBC_SHA376"), is(false));
        // test known cipher with right key size
        assertThat(
                this.keyStore.addKey(Arrays.copyOf(key, 160 / 8), "TLS_PSK_WITH_AES_128_CBC_SHA"),
                is(true));
        // test forbidden cipher
        assertThat(this.keyStore.addKey(key, "TLS_PSK_WITH_AES_128_CCM_8"), is(false));
    }

    /**
     * Test loadKeys with a mocked VslAgentRegistryService.
     */
    @Test
    public final void testLoadKeys() {
        final String[] hashes = new String[] { ("deadbeef"), ("deadbeef1"), ("deadbeef2") };
        final String[] keys = new String[3];
        keys[0] = DatatypeConverter
                .printHexBinary(new KeyStringParser("TLS_PSK_WITH_AES_128_GCM_SHA256").createKey());
        keys[1] = DatatypeConverter.printHexBinary(
                new KeyStringParser("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384").createKey());
        keys[2] = DatatypeConverter
                .printHexBinary(new KeyStringParser("TLS_PSK_WITH_AES_128_GCM_SHA256").createKey());
        final String[] tlsStrings = new String[] { ("TLS_PSK_WITH_AES_128_GCM_SHA256"),
                ("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384"),
                ("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384") };
        final VslAgentRegistryService agentRegistry = Mockito.mock(VslAgentRegistryService.class);
        when(agentRegistry.getAllMulticastGroupKeyHashes()).thenReturn(hashes);
        for (int i = 0; i < 3; i++) {
            when(agentRegistry.getMulticastGroupKey(hashes[i])).thenReturn(keys[i]);
            when(agentRegistry.getMulticastGroupKeyString(hashes[i])).thenReturn(tlsStrings[i]);
        }
        // The third key should not be added as it is too short
        final List<String> results = this.keyStore.loadKeys(agentRegistry);
        assertThat(results.remove(hashes[0]), is(true));
        assertThat(results.remove(hashes[1]), is(true));
        assertThat(results.isEmpty(), is(true));
    }

    /**
     * Tests if a key that has been added to the static keyMap can be removed properly.
     */
    @Test
    public final void testRemoveKey() {
        this.keyStore.addKey(this.key, TLS_STRING);
        assertThat(this.keyStore.removeKey(this.key), is(true));
        assertThat(this.keyStore.removeKey(this.key), is(false));
    }

    /**
     * Test if the key is accessible via the shortened key hashes generated by generateKeyHash().
     *
     * @throws KeyNotInKeystoreException
     *             Thrown if the given key is not in the keystore
     */
    @Test
    public final void testGenerateKeyHash() throws KeyNotInKeystoreException {
        this.keyStore.addKey(key, TLS_STRING);
        byte[] keyHash;
        // test max length hash
        keyHash = this.keyStore.generateKeyHash(key, 256 / 8);
        assertThat(this.keyStore.getKey(keyHash), is(key));
        // Test over length hash
        try {
            keyHash = this.keyStore.generateKeyHash(key, 256 / 8 + 1);
            fail("InvalidParameterException expected.");
        } catch (final InvalidParameterException e) {
            // all good
        }
        // Test hashes of various sizes
        keyHash = this.keyStore.generateKeyHash(key, 2);
        assertThat(this.keyStore.getKey(keyHash), is(key));
        assertThat(this.keyStore.getKeyString(keyHash), is(TLS_STRING));
        keyHash = this.keyStore.generateKeyHash(key, 4);
        assertThat(this.keyStore.getKey(keyHash), is(key));
        assertThat(this.keyStore.getKeyString(keyHash), is(TLS_STRING));
        keyHash = this.keyStore.generateKeyHash(key, 11);
        assertThat(this.keyStore.getKey(keyHash), is(key));
        assertThat(this.keyStore.getKeyString(keyHash), is(TLS_STRING));
        keyHash = this.keyStore.generateKeyHash(key, 17);
        assertThat(this.keyStore.getKey(keyHash), is(key));
        assertThat(this.keyStore.getKeyString(keyHash), is(TLS_STRING));
        keyHash = this.keyStore.generateKeyHash(key, 31);
        assertThat(this.keyStore.getKey(keyHash), is(key));
        assertThat(this.keyStore.getKeyString(keyHash), is(TLS_STRING));

    }

    /**
     * Test for generateMac. Does not test the cryptographic validity of the results.
     *
     * @throws KeyNotInKeystoreException
     *             Thrown if the given key is not in the keystore
     */
    @Test
    public final void testGenerateMAC() throws KeyNotInKeystoreException {
        this.keyStore.addKey(key, TLS_STRING);
        final KeyStringParser parser = new KeyStringParser(TLS_STRING);
        // Use valid key
        final byte[] keyHash = this.keyStore.generateKeyHash(key, 16);
        assertThat((this.keyStore.generateMAC(keyHash, randomData(300))).length,
                is(parser.getMACKeyLength() / 8));
        // Use key that is not in aliasMap
        try {
            this.keyStore.generateMAC(randomData(16), randomData(300));
            fail(); // exception needs to be thrown
        } catch (final KeyNotInKeystoreException e) {
            // all fine
        }
    }

}
