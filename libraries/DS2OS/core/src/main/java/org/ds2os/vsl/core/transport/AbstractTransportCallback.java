package org.ds2os.vsl.core.transport;

import org.ds2os.vsl.core.VslIdentity;
import org.ds2os.vsl.core.VslLockHandler;
import org.ds2os.vsl.core.VslSubscriber;
import org.ds2os.vsl.core.VslVirtualNodeHandler;
import org.ds2os.vsl.core.node.VslNode;
import org.ds2os.vsl.core.utils.VslAddressParameters;
import org.ds2os.vsl.exception.InterruptedOperationException;
import org.ds2os.vsl.exception.SubscriptionNotSupportedException;
import org.ds2os.vsl.exception.TimeoutException;
import org.ds2os.vsl.exception.VslException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * Abstract base class for callbacks, which are generated by a transport module for internal usage
 * in the KA.
 *
 * @author borchers
 * @author felix
 */
public abstract class AbstractTransportCallback
        implements CallbackResponseListener, VslSubscriber, VslLockHandler, VslVirtualNodeHandler {

    private static final Logger LOG = LoggerFactory.getLogger(AbstractTransportCallback.class);
    /**
     * The callback id.
     */
    protected final UUID callbackId;

    /**
     * Map responses per serial number.
     */
    private final Map<Long, CallbackResponseMessage> responseMap;

    /**
     * The next serial number.
     */
    private long nextSerial;

    /**
     * The timeout for callback invocations.
     */
    private final long callbackTimeout;

    /**
     * Constructor with callback id.
     *
     * @param callbackId
     *            the callback id.
     * @param callbackTimeout
     *            the timeout for callback invocations. TODO: configuration for timeouts?
     */
    public AbstractTransportCallback(final UUID callbackId, final long callbackTimeout) {
        this.callbackId = callbackId;
        this.responseMap = new HashMap<Long, CallbackResponseMessage>();
        this.nextSerial = 1L;
        this.callbackTimeout = callbackTimeout;
    }

    /**
     * Get the current callback sender for callback invocations.
     *
     * @return the {@link CallbackSender}.
     * @throws VslException
     *             If no callback sender is available.
     */
    public abstract CallbackSender getCallbackSender() throws VslException;

    @Override
    public final void receivedResponse(final CallbackResponseMessage message) {
        if (!callbackId.equals(message.getCallbackId())) {
            return;
        }
        synchronized (responseMap) {
            responseMap.put(message.getSerial(), message);
            responseMap.notifyAll();
        }
    }

    /**
     * Fetch the response of an invocation with the specified serial number. The response can only
     * be fetched once.
     *
     * @param serial
     *            the serial number of the invocation.
     * @param timeout
     *            the timeout of the wait operation in milliseconds.
     * @return the {@link CallbackResponseMessage} of a successful callback.
     * @throws VslException
     *             If an exception occurs or the response message contains an exception.
     * @throws InterruptedException
     *             If the wait operation got interrupted.
     */
    protected final CallbackResponseMessage fetchResponse(final long serial, final long timeout)
            throws VslException, InterruptedException {
        final long startTime = System.currentTimeMillis();
        synchronized (responseMap) {
            while (!responseMap.containsKey(serial)) {
                final long currentTime = System.currentTimeMillis();
                if (currentTime < startTime + timeout) {
                    responseMap.wait(timeout + startTime - currentTime);
                } else {
                    throw new TimeoutException(timeout, TimeUnit.MILLISECONDS,"Callback timeout occurred");
                }
            }
            final CallbackResponseMessage response = responseMap.remove(serial);
            if (response.getError() == null) {
                return response;
            } else {
                throw response.getError().toException();
            }
        }
    }

    /**
     * Get the next serial number.
     *
     * @return the next serial number.
     */
    protected final long getNextSerial() {
        synchronized (responseMap) {
            return nextSerial++;
        }
    }

    /**
     * Internal helper method for callback invocation.
     *
     * @param method
     *            the {@link CallbackMethod} to invoke.
     * @param address
     *            the address of the invocation.
     * @param identity
     *            the {@link VslIdentity} of the invoker, if needed.
     * @param data
     *            the VSL data supplied with a VSET or null otherwise.
     * @return the VSL data returned by a VGET or null otherwise.
     * @throws VslException
     *             If the callback invocation fails or a timeout or interruption occurs.
     */
    protected final VslNode invokeCallback(final CallbackMethod method, final String address,
            final VslIdentity identity, final VslNode data) throws VslException {
        return invokeCallback(method, address, getNextSerial(), identity, data);
    }

    /**
     * Internal helper method for callback invocation.
     *
     * @param method
     *            the {@link CallbackMethod} to invoke.
     * @param address
     *            the address of the invocation.
     * @param serial
     *            the serial number to identify the response.
     * @param identity
     *            the {@link VslIdentity} of the invoker, if needed.
     * @param data
     *            the VSL data supplied with a VSET or null otherwise.
     * @return the VSL data returned by a VGET or null otherwise.
     * @throws VslException
     *             If the callback invocation fails or a timeout or interruption occurs.
     */
    protected final VslNode invokeCallback(final CallbackMethod method, final String address, final long serial,
                                           final VslIdentity identity, final VslNode data) throws VslException {
        final CallbackSender sender = getCallbackSender();
        sender.setResponseListener(callbackId, this);
        sender.invokeCallback(
                new CallbackInvocationMessage(callbackId, serial, address, method, identity, data));
        LOG.debug("request sent for {}", callbackId + "-" + serial);
        try {
            return fetchResponse(serial, callbackTimeout).getData();
        } catch (final InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new InterruptedOperationException(e);
        } finally {
            LOG.debug("response received for {}", callbackId + "-" + serial);
        }
    }

    @Override
    public final void notificationCallback(final String address) throws VslException {
        invokeCallback(CallbackMethod.NOTIFY, address, null, null);
    }

    @Override
    public final void lockAcquired(final String address) throws VslException {
        invokeCallback(CallbackMethod.LOCK_AQUIRED, address, null, null);
    }

    @Override
    public final void lockWillExpire(final String address) throws VslException {
        invokeCallback(CallbackMethod.LOCK_WILL_EXPIRE, address, null, null);
    }

    @Override
    public final void lockExpired(final String address) throws VslException {
        invokeCallback(CallbackMethod.LOCK_EXPIRED, address, null, null);
    }

    @Override
    public final VslNode get(final String address, final VslAddressParameters params,
            final VslIdentity identity) throws VslException {
        return invokeCallback(CallbackMethod.VGET, address, identity, null);
    }

    @Override
    public final void set(final String address, final VslNode value, final VslIdentity identity)
            throws VslException {
        invokeCallback(CallbackMethod.VSET, address, identity, value);
    }

    @Override
    public final void subscribe(final String address)
            throws SubscriptionNotSupportedException, VslException {
        invokeCallback(CallbackMethod.VSUBSCRIBE, address, null, null);
    }

    @Override
    public final void unsubscribe(final String address) throws VslException {
        invokeCallback(CallbackMethod.VUNSUBSCRIBE, address, null, null);
    }
}
